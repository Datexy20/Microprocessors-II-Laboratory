#include "mcc_generated_files/mcc.h" //default library 



// ++++++++++++ Helpful Notes ++++++++++++++++


/*
 include or set any library or definition you think you will need
 */
#include <htc.h>
// ====================  prototype functions: ====================

/*  example: void Timer2_Init(void)  {}     
 *  Configure Timer 2 and start it
    
 USE Timer 2
 * 
 * ---- Set the Registers below:-----------
 * 
 * 1. Set the Basic Configuration Register for Timer 2 
 * 2. Set the Clock Source in relation with system Oscillator frequency 
 * 3. T2PSYNC Not Synchronized; T2MODE Software control; T2CKPOL Rising Edge; T2CKSYNC Not Synchronized; Timer Mode
 * 4. T2RSEL T2CKIPPS pin; Reset Source
 * 5. Set PR2 255; 
 * 6. Set TMR2  Prescale Value to 0 
 * 7. Clearing IF flag.
 * 8. Start Timer2
 * 
 * ----------------------
 */  



/*  example: void PWM_Init(void)  {}  
 *  Configure CCP1 module in PWM mode (PWM channel = RC3 by default, Timer selection)
  Registers:
 * 
 * --- Set the Registers below: ---
 * 
 * 1. Set up CCP1 module register in PWM mode and bits alignment
 * 2. Set RH to 0; 
 * 3. Set RL to 0; 
 * 4. Selecting Timer 2 - for PWM in CCP1 module
 * 
 * ---------------
  */ 



/*  example: void ADC_Init(void)  {}   
 *  Configure ADC module  
 ----- Set the Registers below::
 * 1. Set ADC CONTROL REGISTER 1 to 0 
 * 2. Set ADC CONTROL REGISTER 2 to 0 
 * 3. Set ADC THRESHOLD REGISTER to 0
 * 4. Disable ADC auto conversion trigger control register
 * 5. Disable ADACT  
 * 6. Clear ADAOV ACC or ADERR not Overflowed  related register
 * 7. Disable ADC Capacitors
 * 8. Set ADC Precharge time control to 0 
 * 9. Set ADC Clock 
 * 10 Set ADC positive and negative references
 * 11. ADC channel - Analog Input
 * 12. Set ADC result alignment, Enable ADC module, Clock Selection Bit, Disable ADC Continuous Operation, Keep ADC inactive
 
  */ 



/*
 PWM_signal_out() prototype function 
 *
 *- you set 10bits value for the duty cycle being careful with the MSB/LSB alignment 
 *- Set the appropriate Registers in the right sequence
 */



/*
 ADC_conversion_results() prototype function
 * 
 * - set your ADC channel , activate the ADC module , and get the ADC result to a value , then deactivate again the ADC module
 * - Set the appropriate Registers in the right sequence
 */

//++++++++++++++++++++++++++++++++++++++++++++++++++++++

#define LED_THRESHOLD 12
#define LED_ROLLOVER 1000

/*
 * Read Me -- Hans
 * Light-sensor/LED controller
 
 * <<led_counter>> holds an integer.  Every infinite loop iteration, led_counter will increment.
 * Once it is equal to LED_ROLLOVER (defined above), led_counter will be set to -1 and the adc conversion will begin.
 * While it is -1, check to see if conversion is done.  If so, set led_counter back to 0 and allow it to increment again, and update the led
 * This method, although complex, saves interrupts for more important things, and it saves clock cycles.
 
 */


/*
Develop your Application logic below
*/

void main(void)
{
    // Initialize PIC device
    SYSTEM_Initialize();
    
    int led_counter;
    led_counter = 0;

    // Initialize the required modules 
   
    // set up conversion parameters
    
	TRISAbits.TRISA0 = 0;			// TRISC bit0 is output
	TRISAbits.TRISA1 = 1;			// PORTC bit1 is input
	ANSELAbits.ANSA1 = 1;				// bit 1 is analog input
    
    ADCON0bits.ADON = 1;			// adc enabled
	ADCON0bits.ADFM = 0;			// left justified
    
    /*This is pprobably gahbage
    ADCON1bits.VCFG     =0b00;// set v+ reference to Vdd
    ADCON1bits.VNCFG    =0b0;  // set v- reference to GND
    ADCON1bits.CHSN     =0b000;// set negative input to GND
    ADCON2bits.ADFM     =0b1;  // right justify the output
    ADCON2bits.ACQT     =0b110;// 16 TAD
    ADCON2bits.ADCS     =0b101;// use Fosc/16 for clock source
     * */
    /*CRAP ^^^*/

	
    // II think this is also a bunch of crap
	//analog channel select pins (AN#)
	//ADCON0 = ADCON0 | 00011100b; //(CHS2,CHS1,CHS0)
	//ADCON0bits.CHS1 = 0;
	//ADCON0bits.CHS0 = 1;

    while (1) // keep your application in a loop
    {
        
        /*START LED/LIGHT SENSOR PART*/
        if (led_counter < 0) {
            // adc conversion is running - check if done
            if (ADCON0bits.GO == 0) {
                // conversion = done
                
                // update led
                if (ADRESH >= LED_THRESHOLD) {
                    LATAbits.LATA0 = 0;
                } else {
                    LATAbits.LATA0 = 1;
                }
                
                led_counter = 0;        // start counter over again
            }   // else, just keep checking every iteration
        } else if (led_counter >= LED_ROLLOVER) {
            // it is time to start an adc conversion
            ADCON0bits.GO = 1;   // start conversion
            led_counter = -1;   // indicates that conversion is running
        } else {
            // neither so just update counter
            ++led_counter;
        }
        /*END LED/LIGHT SENSOR PART*/
        
        
        
        
    }
    
    
}

/**
 End of File
*/
